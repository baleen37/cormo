"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// Generated by CoffeeScript 2.3.1
var AdapterBase, RedisAdapter, _, error, redis, tableize, types, util;
try {
    redis = require('redis');
}
catch (error1) {
    error = error1;
    console.log('Install redis module to use this adapter');
    process.exit(1);
}
AdapterBase = require('./base');
types = require('../types');
tableize = require('../util/inflector').tableize;
_ = require('lodash');
util = require('util');
RedisAdapter = (function () {
    //#
    // Adapter for Redis
    // @namespace adapter
    class RedisAdapter extends AdapterBase {
        _getKeys(table, conditions) {
            return __awaiter(this, void 0, void 0, function* () {
                var all_keys;
                if (Array.isArray(conditions)) {
                    if (conditions.length === 0) {
                        return (yield this._client.keysAsync(`${table}:*`));
                    }
                    all_keys = [];
                    yield Promise.all(conditions.map((condition) => __awaiter(this, void 0, void 0, function* () {
                        var keys;
                        keys = (yield this._getKeys(table, condition));
                        [].push.apply(all_keys, keys);
                    })));
                    return all_keys;
                }
                else if (typeof conditions === 'object' && conditions.id) {
                    if (conditions.id.$in) {
                        return conditions.id.$in.map(function (id) {
                            return `${table}:${id}`;
                        });
                    }
                    else {
                        return [`${table}:${conditions.id}`];
                    }
                }
                return [];
            });
        }
        //#
        // Creates a Redis adapter
        constructor(connection) {
            super();
            this._connection = connection;
        }
        //# @override AdapterBase::drop
        drop(model) {
            return this.delete(model, []);
        }
        valueToDB(value, column, property) {
            if (value == null) {
                return;
            }
            switch (property.type_class) {
                case types.Number:
                case types.Integer:
                    return value.toString();
                case types.Date:
                    return new Date(value).getTime().toString();
                case types.Boolean:
                    if (value) {
                        return '1';
                    }
                    else {
                        return '0';
                    }
                    break;
                case types.Object:
                    return JSON.stringify(value);
                default:
                    return value;
            }
        }
        valueToModel(value, property) {
            switch (property.type_class) {
                case types.Number:
                case types.Integer:
                    return Number(value);
                case types.Date:
                    return new Date(Number(value));
                case types.Boolean:
                    return value !== '0';
                case types.Object:
                    return JSON.parse(value);
                default:
                    return value;
            }
        }
        //# @override AdapterBase::create
        create(model, data) {
            return __awaiter(this, void 0, void 0, function* () {
                var id;
                data.$_$ = ''; // ensure that there is one argument(one field) at least
                try {
                    id = (yield this._client.incrAsync(`${tableize(model)}:_lastid`));
                }
                catch (error1) {
                    error = error1;
                    throw RedisAdapter.wrapError('unknown error', error);
                }
                try {
                    yield this._client.hmsetAsync(`${tableize(model)}:${id}`, data);
                }
                catch (error1) {
                    error = error1;
                    throw RedisAdapter.wrapError('unknown error', error);
                }
                return id;
            });
        }
        //# @override AdapterBase::createBulk
        createBulk(model, data) {
            return __awaiter(this, void 0, void 0, function* () {
                return (yield this._createBulkDefault(model, data));
            });
        }
        //# @override AdapterBase::update
        update(model, data) {
            return __awaiter(this, void 0, void 0, function* () {
                var exists, key;
                key = `${tableize(model)}:${data.id}`;
                delete data.id;
                data.$_$ = ''; // ensure that there is one argument(one field) at least
                try {
                    exists = (yield this._client.existsAsync(key));
                }
                catch (error1) {
                    error = error1;
                    throw RedisAdapter.wrapError('unknown error', error);
                }
                if (!exists) {
                    return;
                }
                try {
                    yield this._client.delAsync(key);
                }
                catch (error1) {
                    error = error1;
                    throw RedisAdapter.wrapError('unknown error', error);
                }
                try {
                    yield this._client.hmsetAsync(key, data);
                }
                catch (error1) {
                    error = error1;
                    throw RedisAdapter.wrapError('unknown error', error);
                }
            });
        }
        //# @override AdapterBase::updatePartial
        updatePartial(model, data, conditions, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var args, fields_to_del, i, key, keys, len, table;
                fields_to_del = Object.keys(data).filter(function (key) {
                    return data[key] == null;
                });
                fields_to_del.forEach(function (key) {
                    return delete data[key];
                });
                fields_to_del.push('$_$'); // ensure that there is one argument at least
                table = tableize(model);
                data.$_$ = ''; // ensure that there is one argument(one field) at least
                keys = (yield this._getKeys(table, conditions));
                for (i = 0, len = keys.length; i < len; i++) {
                    key = keys[i];
                    args = _.clone(fields_to_del);
                    args.unshift(key);
                    try {
                        yield this._client.hdelAsync(args);
                    }
                    catch (error1) {
                        error = error1;
                        if (error) {
                            throw RedisAdapter.wrapError('unknown error', error);
                        }
                    }
                    try {
                        yield this._client.hmsetAsync(key, data);
                    }
                    catch (error1) {
                        error = error1;
                        if (error) {
                            throw RedisAdapter.wrapError('unknown error', error);
                        }
                    }
                }
                return keys.length;
            });
        }
        //# @override AdapterBase::findById
        findById(model, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var result;
                try {
                    result = (yield this._client.hgetallAsync(`${tableize(model)}:${id}`));
                }
                catch (error1) {
                    error = error1;
                    throw RedisAdapter.wrapError('unknown error', error);
                }
                if (result) {
                    result.id = id;
                    return this._convertToModelInstance(model, result, options);
                }
                else {
                    throw new Error('not found');
                }
            });
        }
        //# @override AdapterBase::find
        find(model, conditions, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var keys, records, table;
                table = tableize(model);
                keys = (yield this._getKeys(table, conditions));
                records = (yield Promise.all(keys.map((key) => __awaiter(this, void 0, void 0, function* () {
                    var result;
                    result = (yield this._client.hgetallAsync(key));
                    if (result) {
                        result.id = Number(key.substr(table.length + 1));
                    }
                    return result;
                }))));
                records = records.filter(function (record) {
                    return record != null;
                });
                return records.map((record) => {
                    return this._convertToModelInstance(model, record, options);
                });
            });
        }
        //# @override AdapterBase::delete
        delete(model, conditions) {
            return __awaiter(this, void 0, void 0, function* () {
                var count, keys;
                keys = (yield this._getKeys(tableize(model), conditions));
                if (keys.length === 0) {
                    return 0;
                }
                try {
                    count = (yield this._client.delAsync(keys));
                }
                catch (error1) {
                    error = error1;
                    throw RedisAdapter.wrapError('unknown error', error);
                }
                return count;
            });
        }
        //#
        // Connects to the database
        // @param {Object} settings
        // @param {String} [settings.host='127.0.0.1']
        // @param {Number} [settings.port=6379]
        // @param {Number} [settings.database=0]
        connect(settings) {
            return __awaiter(this, void 0, void 0, function* () {
                var i, len, method, methods;
                methods = ['del', 'exists', 'hdel', 'hgetall', 'hmset', 'incr', 'keys', 'select'];
                this._client = redis.createClient(settings.port || 6379, settings.host || '127.0.0.1');
                for (i = 0, len = methods.length; i < len; i++) {
                    method = methods[i];
                    this._client[method + 'Async'] = util.promisify(this._client[method]);
                }
                return (yield this._client.selectAsync(settings.database || 0));
            });
        }
    }
    ;
    RedisAdapter.prototype.support_upsert = false;
    RedisAdapter.prototype.key_type = types.Integer;
    return RedisAdapter;
}).call(this);
module.exports = function (connection) {
    return new RedisAdapter(connection);
};
